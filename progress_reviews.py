from pathlib import Path
import xml.etree.ElementTree as ET
from datetime import datetime
import re

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import mpld3
from mpld3 import plugins

from astropy import table
from astropy import time
from astropy.io import fits

import database_utilities as dbutils

data_folder = Path('/Users/parke/Google Drive/Research/STELa/data/uv_observations/hst-stis')
progress_folder = Path('progress_reviews')
status_folder = progress_folder / 'status_table_snapshots'

saveplots = True

#%% filters for observation files to process

# targets = ['hd17156', 'k2-9', 'toi-1434', 'toi-1696', 'wolf503', 'hd207496']
# targets = ['toi-2015', 'toi-2079']
targets = 'any'

obs_filters = dict(targets=targets, after='2020', directory=data_folder)


#%% make a csv of the observation dates to drop into the main progress spreadsheet
# most of this generated by ChatGPT

main_table = pd.read_excel(status_folder / 'Observation Progress.xlsx', keep_default_na=False)
main_table = table.Table.from_pandas(main_table)
column_map = (('Rank', 'Rank'),
              ('Lya Visit\nLabel', 'lya visit'),
              ('Planned\nLya Obs', 'lya plandate'),
              ('Last Lya\nObs', 'lya obsdate'),
              ('FUV Visit\nLabel', 'fuv visit'),
              ('Planned\nFUV Obs', 'fuv plandate'),
              ('Last FUV \nObs', 'fuv obsdate'))
oldcols, newcols = zip(*column_map)
modified_table = main_table[oldcols].copy()
modified_table.rename_columns(oldcols, newcols)
lya_labels = modified_table['lya visit'].tolist()
fuv_labels = modified_table['fuv visit'].tolist()
modified_table['lya planned'] = False
modified_table['fuv planned'] = False
datecols = 'lya plandate', 'lya obsdate', 'fuv plandate', 'fuv obsdate'
for col in datecols:
        modified_table[col] = modified_table[col].astype('object')


tree = ET.parse(status_folder / 'HST-17804-visit-status.xml')
root = tree.getroot()

def parse_planwindow_date(text):
    """ Extracts the left-most date from a planWindow string. Expected input example: "Mar 31, 2025 - Apr 1, 2025 (2025.090 - 2025.091)" This function takes the first date (e.g. "Mar 31, 2025") and returns a datetime object. """
    try: # Split on the hyphen and take the first part
        date_part = text.split(" - ")[0].strip() # Parse the date; expected format e.g. "Mar 31, 2025"
        parsed_date = datetime.strptime(date_part, "%b %d, %Y")
        return parsed_date
    except Exception as e:
        return None

records = []
# Iterate over each visit element in the report
for visit in root.findall('visit'):
    visit_label = visit.attrib.get('visit')
    if visit_label in lya_labels:
        i = lya_labels.index(visit_label)
        stage = 'lya'
    elif visit_label in fuv_labels:
        i = fuv_labels.index(visit_label)
        stage = 'fuv'
    else:
        raise ValueError('Visit label not found.')

    # mark observation as in the phase II
    modified_table[f'{stage} planned'][i] = True

    plancol = f'{stage} plandate'
    obscol = f'{stage} obsdate'

    # Get the status text (if available)
    status_elem = visit.find('status')
    status = status_elem.text.strip() if status_elem is not None else ""

    # Get all planWindow elements (if any)
    plan_windows = visit.findall('planWindow')

    # Check if this visit is flagged as "not a candidate..."
    if status == "Executed":
        # For executed visits use the startTime as the actual observation date.
        start_time_elem = visit.find('startTime')
        if start_time_elem is not None and start_time_elem.text:
            actual_obs, = re.findall(r'\w{3} \d+, \d{4}', start_time_elem.text)
            modified_table[obscol][i] = actual_obs
    else:
        # For visits that have not executed (Scheduled, Flight Ready, Implementation, etc.)
        # if planWindow elements exist, extract the earliest possible observation date.
        dates = []
        for pw in plan_windows:
            if pw.text:
                dt = parse_planwindow_date(pw.text)
                if dt:
                    dates.append(dt)
        if dates:
            earliest_date = min(dates)
            # Format the date as "Mon DD, YYYY" (e.g., "Mar 31, 2025")
            earliest_possible = earliest_date.strftime("%b %d, %Y")
            modified_table[plancol][i] = earliest_possible

today = datetime.today().strftime("%Y-%m-%d")
modified_table.write(status_folder / f'visit_dates_for_copy-paste_{today}.csv', overwrite=True)


#%% make cumulative progress plots

for stage in ['lya', 'fuv']:
    mask = modified_table[f'{stage} planned']
    n = np.sum(mask)
    ivec = np.arange(n) + 1
    datelists = []
    for datekey in ['obsdate', 'plandate']:
        date_strings = modified_table[f'{stage} {datekey}'][mask]
        dates = []
        for datestr in date_strings:
            if datestr in ['', 'SNAP']:
                continue
            try:
                date = time.Time(datestr)
            except ValueError:
                _ = datetime.strptime(datestr, "%b %d, %Y")
                date = time.Time(_)
            dates.append(date)
        dates = time.Time(sorted(dates))
        datelists.append(dates)
    obsdates, plandates = datelists

    plt.figure()
    nobs = len(obsdates)
    nplan = len(plandates)
    plt.plot(obsdates.decimalyear, ivec[:nobs], 'k-', lw=2)
    plt.plot(plandates.decimalyear, ivec[nobs:nobs+nplan], '--', lw=2, color='0.5')
    plt.axhline(n, color='C2', lw=2)
    plt.xlabel('Date')
    plt.ylabel(f'{stage} Observations Executed')
    plt.tight_layout()
    plt.savefig(progress_folder / f'{stage} progress chart.pdf')
    plt.savefig(progress_folder / f'{stage} progress chart.png', dpi=300)


#%% check acquisitions

rawfiles = dbutils.find_data_files('raw', 'hst-stis-mirvis', **obs_filters)

stages = ['coarse', 'fine', '0.2x0.2']
for file in rawfiles:
    fig, axs = plt.subplots(1, 3, figsize=[7,3])
    h = fits.open(file)
    for i, ax in enumerate(axs):
        data = h['sci', i+1].data
        ax.imshow(data)
        ax.set_title('')
    fig.suptitle(file.name)
    fig.supxlabel('dispersion')
    fig.supylabel('spatial')
    fig.tight_layout()


#%% plot extraction locations

fltfiles = dbutils.find_data_files('flt', instruments='hst-stis', **obs_filters)

for ff in fltfiles:
    img = fits.getdata(ff, 1)
    f1 = dbutils.modify_file_label(ff, 'x1d')
    td = fits.getdata(f1, 1)
    fig = plt.figure()
    plt.imshow(np.cbrt(img), aspect='auto')
    plt.title(ff.name)

    x = np.arange(img.shape[1]) + 0.5
    y = td['extrlocy']
    ysz = td['extrsize']
    plt.plot(x, y.T, color='w', lw=0.5, alpha=0.5)
    for _y, _ysz in zip(y, ysz):
        plt.fill_between(x, _y - _ysz/2, _y + _ysz/2, color='w', lw=0, alpha=0.5)
    for ibk in (1,2):
        off, sz = td[f'bk{ibk}offst'], td[f'bk{ibk}size']
        ym = y + off[:,None]
        y1, y2 = ym - sz[:,None]/2, ym + sz[:,None]/2
        for yy1, yy2 in zip(y1, y2):
            plt.fill_between(x, yy1, yy2, color='0.5', alpha=0.5, lw=0)

    if saveplots:
        dpi = fig.get_dpi()
        fig.set_dpi(150)
        plugins.connect(fig, plugins.MousePosition(fontsize=14))
        figfile = str(ff).replace('_flt.fits', '_extraction.html')
        mpld3.save_html(fig, figfile)
        fig.set_dpi(dpi)


#%% plot spectra

# TODO add an estimate of where the airglow should land just based on Earth and HST's velocity
